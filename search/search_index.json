{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#template-de-entrega","title":"Template de Entrega","text":"Edi\u00e7\u00e3o <p>2025.1</p>"},{"location":"#grupokit-x","title":"Grupo/Kit X","text":"<ol> <li>Alexandre Martinelli</li> <li>Andr\u00e9 Henrique Pacheco Alves</li> <li>Gabriel Cardoso Campos Rodrigues</li> <li>Hugo Coscelli Ferraz</li> <li>Julia Akemi Mullis</li> <li>Theo Camuri Gaspar</li> <li>Grupo Masked Penguins<ul> <li>Jo\u00e3o da Silva</li> <li>Pedro de Souza</li> </ul> </li> </ol> <p>Instru\u00e7\u00f5es</p> <p>Voc\u00eas devem utilizar este template como um bloco de notas para registrar o que foi feito e o que falta fazer. Voc\u00eas devem adicionar as informa\u00e7\u00f5es necess\u00e1rias. O template deve ser editado e atualizado a cada entrega, registrando assim a data de entrega e o que foi feito at\u00e9 o momento via Git.</p>"},{"location":"#entregas","title":"Entregas","text":"<ul> <li> Roteiro 1 - Data 23/02/2025</li> <li> Roteiro 2</li> <li> Roteiro 3</li> <li> Roteiro 4</li> <li> Projeto</li> </ul>"},{"location":"#diagramas","title":"Diagramas","text":"<p>Use o Mermaid para criar os diagramas de documenta\u00e7\u00e3o.</p> <p>Mermaid Live Editor</p> <pre><code>flowchart TD\n    Deployment:::orange --&gt;|defines| ReplicaSet\n    ReplicaSet --&gt;|manages| pod((Pod))\n    pod:::red --&gt;|runs| Container\n    Deployment --&gt;|scales| pod\n    Deployment --&gt;|updates| pod\n\n    Service:::orange --&gt;|exposes| pod\n\n    subgraph  \n        ConfigMap:::orange\n        Secret:::orange\n    end\n\n    ConfigMap --&gt; Deployment\n    Secret --&gt; Deployment\n    classDef red fill:#f55\n    classDef orange fill:#ffa500</code></pre>"},{"location":"#codigos","title":"C\u00f3digos","text":"De um arquivo remotoAnota\u00e7\u00f5es no c\u00f3digo main.yaml<pre><code>name: ci\non:\n  - push\n  - pull_request\n\n# Environment\nenv:\n  CI: true\n  PYTHON_VERSION: 3.12\n\n# Jobs to run\njobs:\n\n  # Build and deploy documentation site\n  deploy:\n    if: github.event_name != 'pull_request' &amp;&amp; github.ref == 'refs/heads/main'\n    runs-on: ubuntu-latest\n    steps:\n\n      # Checkout source form GitHub\n      - uses: actions/checkout@v4\n\n      # Install Python runtime and dependencies\n      - uses: actions/setup-python@v4\n        with:\n          python-version: ${{ env.PYTHON_VERSION }}\n\n      # pip\n      - run: |\n          pip install -r requirements.txt\n\n      # deploy\n      - run: |\n          mkdocs gh-deploy --force\n</code></pre> compose.yaml<pre><code>name: app\n\n    db:\n        image: postgres:17\n        environment:\n            POSTGRES_DB: ${POSTGRES_DB:-projeto} # (1)!\n            POSTGRES_USER: ${POSTGRES_USER:-projeto}\n            POSTGRES_PASSWORD: ${POSTGRES_PASSWORD:-projeto}\n        ports:\n            - 5432:5432 #(2)!\n</code></pre> <ol> <li> <p>Caso a vari\u00e1vel de ambiente <code>POSTGRES_DB</code> n\u00e3o exista ou seja nula - n\u00e3o seja definida no arquivo <code>.env</code> - o valor padr\u00e3o ser\u00e1 <code>projeto</code>. Vide documenta\u00e7\u00e3o.</p> </li> <li> <p>Aqui \u00e9 feito um t\u00fanel da porta 5432 do container do banco de dados para a porta 5432 do host (no caso localhost). Em um ambiente de produ\u00e7\u00e3o, essa porta n\u00e3o deve ser exposta, pois ningu\u00e9m de fora do compose deveria acessar o banco de dados diretamente.</p> </li> </ol>"},{"location":"#exemplo-de-video","title":"Exemplo de v\u00eddeo","text":"<p>Lorem ipsum dolor sit amet</p>"},{"location":"#referencias","title":"Refer\u00eancias","text":"<p>Material for MkDocs</p> <p>hsandmann</p>"},{"location":"KNN/main/","title":"KNN","text":""},{"location":"KNN/main/#entrega-individual","title":"Entrega Individual","text":"<ol> <li>Alexandre Martinelli</li> </ol>"},{"location":"KNN/main/#introducao","title":"Introdu\u00e7\u00e3o","text":"<ol> <li>Explora\u00e7\u00e3o de dados: Ao selecionar uma base no kaggle referentes a cinco tipos de rem\u00e9dio, rem\u00e9dio A, B, C, X e Y, tem como objetivo prever qual rem\u00e9dio o paciente teria uma resposta melhor. As colunas presentes nesse dataset s\u00e3o Idade, Sexo, Press\u00e3o Arterial, nivel de colesterol, nivel de s\u00f3dio para pot\u00e1ssio no sangue e rem\u00e9dio que seria nossa target. </li> </ol>"},{"location":"KNN/main/#colunas","title":"Colunas","text":"<ol> <li>Age (Idade): Essa coluna temos a idade dos pacientes, com a idade minima presente de 15, idade m\u00e9dia de 44,3 e maxima de 74 sendo do tipo Integer. </li> <li>Sex (Sexo): Essa coluna tem o sexo de cada paciente, divididos em 52% Masculino e 48% feminino, dados do tipo String.</li> <li>Blood Pressure (Press\u00e3o Arterial): Essa coluna tem os niveis de press\u00e3o arterial de cada paciente sendo dividida em 39% HIGH, 29% NORMAL e 32% LOW, dados do tipo String.</li> <li>Cholesterol (nivel de colesterol): Essa coluna tem os niveis de colesterol de cada paciente sendo divididos em 52% HIGH e 49% NORMAL, dados do tipo String.</li> <li>Na_to_K (s\u00f3dio para pot\u00e1ssio): Essa coluna tem os a raz\u00e3o de s\u00f3dio para pot\u00e1ssio no sangue de um paciente, com a minima de 6,27, media de 16,1 e maxima de 38,2, dados do tipo Float/Decimal.</li> <li>Drug (rem\u00e9dio): Essa coluna tem os rem\u00e9dio de melhor resposta para o paciente, dados do tipo String.</li> </ol> Base Age Sex BP Cholesterol Na_to_K Drug 36 M LOW NORMAL 11.424 drugX 16 F HIGH NORMAL 15.516 drugY 18 F NORMAL NORMAL 8.75 drugX 59 F LOW HIGH 10.444 drugC 47 M LOW NORMAL 33.542 drugY 51 M HIGH HIGH 18.295 drugY 18 F HIGH NORMAL 24.276 drugY 28 F NORMAL HIGH 12.879 drugX 42 M HIGH NORMAL 12.766 drugA 66 F NORMAL NORMAL 8.107 drugX"},{"location":"KNN/main/#pre-processamento","title":"Pr\u00e9-processamento","text":"<p>Primeiro foi feita uma verifica\u00e7\u00e3o em todas as colunas procurando valores faltantes e substituindo eles pela mediana em valores num\u00e9ricos ou pela moda em vari\u00e1veis categ\u00f3ricas. Como vimos na descri\u00e7\u00e3o das colunas temos tr\u00eas que possuem dados categ\u00f3ricos do tipo String, sendo elas Sex(Sexo), Blood Pressure(Press\u00e3o Arterial) e Cholesterol(nivel de colesterol), para conseguirmos utilizar essas informa\u00e7\u00f5es \u00e9 necessario convertelas em numeros, oque foi feito utilizando a biblioteca scikit-learn que possui a fun\u00e7\u00e3o LabelEncoder(), em seguida aplicamos dois tipos de escalonamento \u00e0s colunas num\u00e9ricas Age e Na_to_K: padroniza\u00e7\u00e3o (z-score) e normaliza\u00e7\u00e3o min-max.</p> ResultPrep CodeStandardizationStandardization code N-Age Sex BP Cholesterol N-Na_to_K Drug 0.4 1 1 1 0.130411 drugX 0 0 0 1 0.291292 drugY 0.04 0 2 1 0.0252801 drugX 0.86 0 1 0 0.0918813 drugC 0.62 1 1 1 1 drugY 0.7 1 0 0 0.40055 drugY 0.04 0 0 1 0.635699 drugY 0.24 0 2 0 0.187615 drugX 0.52 1 0 1 0.183173 drugA 1 0 2 1 0 drugX <pre><code>import pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\n\n# Preprocess the data\ndef preprocess(df):\n    # Fill missing values\n    df['Age'].fillna(df['Age'].median(), inplace=True)\n    df['Sex'].fillna(df['Sex'].mode()[0], inplace=True)\n    df['BP'].fillna(df['BP'].mode()[0], inplace=True)\n    df['Cholesterol'].fillna(df['Cholesterol'].mode()[0], inplace=True)\n    df['Na_to_K'].fillna(df['Na_to_K'].median(), inplace=True)\n    df['Drug'].fillna(df['Drug'].mode()[0], inplace=True)\n\n   # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['Sex'] = label_encoder.fit_transform(df['Sex'])\n    df['BP'] = label_encoder.fit_transform(df['BP'])\n    df['Cholesterol'] = label_encoder.fit_transform(df['Cholesterol'])\n\n    # Select features\n    features = ['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K', 'Drug']\n    return df[features]\n\n# Load the dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/alexandremartinelli11/machine-learning/refs/heads/main/data/kaggle/drug200.csv')\ndf = df.sample(n=10, random_state=42)\n\n# Preprocessing\ndf = preprocess(df)\n\n# Display the first few rows of the dataset\nprint(df.to_markdown(index=False))\n</code></pre> Age N-Age Z-Age Na_to_K N-Na_to_K Z-Na_to_K 95 36 0.4 -0.117416 11.424 0.130411 -0.526121 15 16 0 -1.23566 15.516 0.291292 -0.0105705 30 18 0.04 -1.12384 8.75 0.0252801 -0.863018 158 59 0.86 1.16857 10.444 0.0918813 -0.649591 128 47 0.62 0.49762 33.542 1 2.26052 115 51 0.7 0.72127 18.295 0.40055 0.339555 69 18 0.04 -1.12384 24.276 0.635699 1.0931 170 28 0.24 -0.564715 12.879 0.187615 -0.342806 174 42 0.52 0.218058 12.766 0.183173 -0.357043 45 66 1 1.55996 8.107 0 -0.944029 <pre><code>import pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\n\ndef standardization(df):\n\n    df['Z-Age'] = df['Age'].apply(lambda x: (x-df['Age'].mean())/df['Age'].std())\n    df['N-Age'] = df['Age'].apply(lambda x: (x-df['Age'].min())/(df['Age'].max()-df['Age'].min()))\n    df['Z-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x-df['Na_to_K'].mean())/df['Na_to_K'].std())\n    df['N-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x-df['Na_to_K'].min())/(df['Na_to_K'].max()-df['Na_to_K'].min()))\n    df = df[['Age', 'N-Age', 'Z-Age', 'Na_to_K', 'N-Na_to_K', 'Z-Na_to_K']].dropna()\n    print(df.head(10).to_markdown())\n\ndef preprocess(df):\n    # Fill missing values\n    df['Age'].fillna(df['Age'].median(), inplace=True)\n    df['Sex'].fillna(df['Sex'].mode()[0], inplace=True)\n    df['BP'].fillna(df['BP'].mode()[0], inplace=True)\n    df['Cholesterol'].fillna(df['Cholesterol'].mode()[0], inplace=True)\n    df['Na_to_K'].fillna(df['Na_to_K'].median(), inplace=True)\n    df['Drug'].fillna(df['Drug'].mode()[0], inplace=True)\n\n   # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['Sex'] = label_encoder.fit_transform(df['Sex'])\n    df['BP'] = label_encoder.fit_transform(df['BP'])\n    df['Cholesterol'] = label_encoder.fit_transform(df['Cholesterol'])\n\n    # Select features\n    features = ['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K', 'Drug']\n    return df[features]\n\n# Load the dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/alexandremartinelli11/machine-learning/refs/heads/main/data/kaggle/drug200.csv')\ndf = df.sample(n=10, random_state=42)\n\n# Preprocessing\ndf = preprocess(df)\n\nstandardization(df)\n</code></pre>"},{"location":"KNN/main/#divisao-dos-dados","title":"Divis\u00e3o dos Dados","text":"<p>O conjunto de dados foi dividido em 70% para treino e 30% para valida\u00e7\u00e3o, garantindo que o modelo fosse treinado em uma parte significativa das observa\u00e7\u00f5es, mas ainda avaliado em dados n\u00e3o vistos. O uso do conjunto de valida\u00e7\u00e3o tem como objetivo detectar e reduzir o risco de overfitting.</p>"},{"location":"KNN/main/#treinamento-do-modelo","title":"Treinamento do Modelo","text":"<p>Foi utilizada a fun\u00e7\u00e3o <code>permutation_importance()</code> para identificar as features de maior relevancia para o modelo, essa fun\u00e7\u00e3o funciona de seguinte forma: \u00e9 calculada a <code>acur\u00e1cia</code> original do modelo e ap\u00f3s isso ele vai em cada feature embaralhando/permutando os valores no conjunto de teste. Ao finalizar esse processo recalcula a <code>acur\u00e1cia</code> para cada dimens\u00e3o permutada e compara o quanto ela caiu em rela\u00e7\u00e3o a original.</p> Result 70% 30%Code <p>Accuracy: 0.93 Feature Importances (Permutation):  Feature Importance Std N-Na_to_K 0.397222 0.070983 BP 0.332222 0.037990 Cholesterol 0.149444 0.041160 N-Age 0.088889 0.035048 </p>Relat\u00f3rio de Classifica\u00e7\u00e3o: precision recall f1-score support 0 1.000000 0.714286 0.833333 7.000000 1 0.428571 1.000000 0.600000 3.000000 2 1.000000 1.000000 1.000000 6.000000 3 1.000000 1.000000 1.000000 18.000000 4 1.000000 0.923077 0.960000 26.000000 accuracy 0.933333 0.933333 0.933333 0.933333 macro avg 0.885714 0.927473 0.878667 60.000000 weighted avg 0.971429 0.933333 0.943222 60.000000 2025-09-28T23:59:31.746222 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ 2025-09-28T23:59:31.965381 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ <p></p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom io import StringIO\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import accuracy_score, classification_report, confusion_matrix\nimport seaborn as sns\nimport pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.inspection import permutation_importance\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import StandardScaler\nfrom itertools import cycle\n\nplt.figure(figsize=(12, 10))\n\ndef standardization(df):\n\n    df['Z-Age'] = df['Age'].apply(lambda x: (x-df['Age'].mean())/df['Age'].std())\n    df['N-Age'] = df['Age'].apply(lambda x: (x-df['Age'].min())/(df['Age'].max()-df['Age'].min()))\n    df['Z-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x-df['Na_to_K'].mean())/df['Na_to_K'].std())\n    df['N-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x-df['Na_to_K'].min())/(df['Na_to_K'].max()-df['Na_to_K'].min()))\n    features = ['N-Age', 'Sex', 'BP', 'Cholesterol', 'N-Na_to_K', 'Drug']\n    return df[features]\n\ndef preprocess(df):\n    # Fill missing values\n    df['Age'].fillna(df['Age'].median(), inplace=True)\n    df['Sex'].fillna(df['Sex'].mode()[0], inplace=True)\n    df['BP'].fillna(df['BP'].mode()[0], inplace=True)\n    df['Cholesterol'].fillna(df['Cholesterol'].mode()[0], inplace=True)\n    df['Na_to_K'].fillna(df['Na_to_K'].median(), inplace=True)\n    df['Drug'].fillna(df['Drug'].mode()[0], inplace=True)\n\n   # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['Sex'] = label_encoder.fit_transform(df['Sex'])\n    df['BP'] = label_encoder.fit_transform(df['BP'])\n    df['Cholesterol'] = label_encoder.fit_transform(df['Cholesterol'])\n    df['Drug'] = label_encoder.fit_transform(df['Drug'])\n\n    # Select features\n    features = ['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K', 'Drug']\n    return df[features]\n\n# Load the dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/alexandremartinelli11/machine-learning/refs/heads/main/data/kaggle/drug200.csv')\n\n# Preprocessing\nd = preprocess(df.copy())\nd = standardization(d)\n\n\n# Generate synthetic dataset\nX = d[['N-Age', 'BP', 'Cholesterol', 'N-Na_to_K']]\ny = d['Drug']\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)\n\n# Train KNN model\nknn = KNeighborsClassifier(n_neighbors=3)\nknn.fit(X_train, y_train)\npredictions = knn.predict(X_test)\nprint(f\"Accuracy: {accuracy_score(y_test, predictions):.2f}\")\n\n\nr = permutation_importance(\n    knn,                  \n    X_test,               \n    y_test,               \n    n_repeats=30,         \n    random_state=42,\n    scoring='accuracy'    \n)\n\n\nfeature_importance = pd.DataFrame({\n    'Feature': X.columns,\n    'Importance': r.importances_mean,\n    'Std': r.importances_std\n})\n\nreport_dict = classification_report(y_test, predictions, output_dict=True)\nreport_df = pd.DataFrame(report_dict).transpose()\n\ncm = confusion_matrix(y_test, predictions)\nlabels = knn.classes_\ncm_df = pd.DataFrame(cm, index=labels, columns=labels)\n\n# ordenar e mostrar (HTML igual ao seu exemplo)\nfeature_importance = feature_importance.sort_values(by='Importance', ascending=False)\nprint(\"&lt;br&gt;Feature Importances (Permutation):\")\nprint(feature_importance.to_html(index=False))\n\nprint(\"&lt;h3&gt;Relat\u00f3rio de Classifica\u00e7\u00e3o:&lt;/h3&gt;\")\nprint(report_df.to_html(classes=\"table table-bordered table-striped\", border=0))\n\n# Escalar features\nscaler = StandardScaler()\nX_scaled = scaler.fit_transform(X)\n\n# Reduzir para 2 dimens\u00f5es (apenas para visualiza\u00e7\u00e3o)\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X_scaled)\n\n# Split train/test\nX_train, X_test, y_train, y_test = train_test_split(X_pca, y, test_size=0.3, random_state=42)\n\n# Treinar KNN\nknn = KNeighborsClassifier(n_neighbors=3)\nknn.fit(X_train, y_train)\npredictions = knn.predict(X_test)\n\n\n# Visualize decision boundary\nh = 0.02  # Step size in mesh\nx_min, x_max = X_pca[:, 0].min() - 1, X_pca[:, 0].max() + 1\ny_min, y_max = X_pca[:, 1].min() - 1, X_pca[:, 1].max() + 1\nxx, yy = np.meshgrid(np.arange(x_min, x_max, h), np.arange(y_min, y_max, h))\n\nZ = knn.predict(np.c_[xx.ravel(), yy.ravel()])\nZ = Z.reshape(xx.shape)\n\nplt.contourf(xx, yy, Z, cmap=plt.cm.RdYlBu, alpha=0.3)\nsns.scatterplot(x=X_pca[:, 0], y=X_pca[:, 1], hue=y, style=y, palette=\"deep\", s=100)\nplt.xlabel(\"Feature 1\")\nplt.ylabel(\"Feature 2\")\nplt.title(\"KNN Decision Boundary (k=3)\")\n\n# Display the plot\nbuffer = StringIO()\nplt.savefig(buffer, format=\"svg\", transparent=True)\nprint(buffer.getvalue())\n</code></pre>"},{"location":"KNN/main/#avaliacao-do-modelo","title":"Avalia\u00e7\u00e3o do Modelo","text":"<p>O modelo KNN (k=3) obteve aproximadamente 0,93 de acur\u00e1cia nos dados de teste, indicando bom desempenho geral. A an\u00e1lise da curva ROC multiclasse (One-vs-Rest) mostra que todas as classes, exceto uma, apresentam \u00e1rea sob a curva (AUC) igual a 1,0, enquanto a \u00faltima classe apresenta AUC de 0,99, sinalizando que o modelo praticamente n\u00e3o erra na maioria das classes, mas pode cometer alguns erros sutis na previs\u00e3o de uma classe espec\u00edfica. Apesar da alta acur\u00e1cia e AUC, \u00e9 recomend\u00e1vel comparar o desempenho nos dados de treino e teste para verificar poss\u00edveis sinais de overfitting. Para aprimorar o modelo, podemos testar diferentes Ks no KNN e usar  t\u00e9cnicas de balanceamento de classes caso haja desbalanceamento.</p>"},{"location":"KNN/main/#referencias","title":"Refer\u00eancias","text":"<p>Material for MkDocs</p>"},{"location":"arvore/main/","title":"\u00c1rvore de Decis\u00e3o","text":""},{"location":"arvore/main/#entrega-individual","title":"Entrega Individual","text":"<ol> <li>Alexandre Martinelli</li> </ol>"},{"location":"arvore/main/#introducao","title":"Introdu\u00e7\u00e3o","text":"<ol> <li>Explora\u00e7\u00e3o de dados: Ao selecionar uma base no kaggle referentes a cinco tipos de rem\u00e9dio, rem\u00e9dio A, B, C, X e Y, tem como objetivo prever qual rem\u00e9dio o paciente teria uma resposta melhor. As colunas presentes nesse dataset s\u00e3o Idade, Sexo, Press\u00e3o Arterial, nivel de colesterol, nivel de s\u00f3dio para pot\u00e1ssio no sangue e rem\u00e9dio que seria nossa target. </li> </ol>"},{"location":"arvore/main/#colunas","title":"Colunas","text":"<ol> <li>Age (Idade): Essa coluna temos a idade dos pacientes, com a idade minima presente de 15, idade m\u00e9dia de 44,3 e maxima de 74 sendo do tipo Integer. </li> <li>Sex (Sexo): Essa coluna tem o sexo de cada paciente, divididos em 52% Masculino e 48% feminino, dados do tipo String.</li> <li>Blood Pressure (Press\u00e3o Arterial): Essa coluna tem os niveis de press\u00e3o arterial de cada paciente sendo dividida em 39% HIGH, 29% NORMAL e 32% LOW, dados do tipo String.</li> <li>Cholesterol (nivel de colesterol): Essa coluna tem os niveis de colesterol de cada paciente sendo divididos em 52% HIGH e 49% NORMAL, dados do tipo String.</li> <li>Na_to_K (s\u00f3dio para pot\u00e1ssio): Essa coluna tem os a raz\u00e3o de s\u00f3dio para pot\u00e1ssio no sangue de um paciente, com a minima de 6,27, media de 16,1 e maxima de 38,2, dados do tipo Float/Decimal.</li> <li>Drug (rem\u00e9dio): Essa coluna tem os rem\u00e9dio de melhor resposta para o paciente, dados do tipo String.</li> </ol> Base Age Sex BP Cholesterol Na_to_K Drug 36 M LOW NORMAL 11.424 drugX 16 F HIGH NORMAL 15.516 drugY 18 F NORMAL NORMAL 8.75 drugX 59 F LOW HIGH 10.444 drugC 47 M LOW NORMAL 33.542 drugY 51 M HIGH HIGH 18.295 drugY 18 F HIGH NORMAL 24.276 drugY 28 F NORMAL HIGH 12.879 drugX 42 M HIGH NORMAL 12.766 drugA 66 F NORMAL NORMAL 8.107 drugX"},{"location":"arvore/main/#pre-processamento","title":"Pr\u00e9-processamento","text":"<p>Primeiro foi feita uma verifica\u00e7\u00e3o em todas as colunas procurando valores faltantes e substituindo eles pela mediana em valores num\u00e9ricos ou pela moda em vari\u00e1veis categ\u00f3ricas. Como vimos na descri\u00e7\u00e3o das colunas temos tr\u00eas que possuem dados categ\u00f3ricos do tipo String, sendo elas Sex(Sexo), Blood Pressure(Press\u00e3o Arterial) e Cholesterol(nivel de colesterol), para conseguirmos utilizar essas informa\u00e7\u00f5es \u00e9 necessario convertelas em numeros, oque foi feito utilizando a biblioteca scikit-learn que possui a fun\u00e7\u00e3o LabelEncoder(), em seguida aplicamos dois tipos de escalonamento \u00e0s colunas num\u00e9ricas Age e Na_to_K: padroniza\u00e7\u00e3o (z-score) e normaliza\u00e7\u00e3o min-max.</p> ResultPrep CodeStandardizationStandardization code N-Age Sex BP Cholesterol N-Na_to_K Drug 0.4 1 1 1 0.130411 drugX 0 0 0 1 0.291292 drugY 0.04 0 2 1 0.0252801 drugX 0.86 0 1 0 0.0918813 drugC 0.62 1 1 1 1 drugY 0.7 1 0 0 0.40055 drugY 0.04 0 0 1 0.635699 drugY 0.24 0 2 0 0.187615 drugX 0.52 1 0 1 0.183173 drugA 1 0 2 1 0 drugX <pre><code>import pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\n\n# Preprocess the data\ndef preprocess(df):\n    # Fill missing values\n    df['Age'].fillna(df['Age'].median(), inplace=True)\n    df['Sex'].fillna(df['Sex'].mode()[0], inplace=True)\n    df['BP'].fillna(df['BP'].mode()[0], inplace=True)\n    df['Cholesterol'].fillna(df['Cholesterol'].mode()[0], inplace=True)\n    df['Na_to_K'].fillna(df['Na_to_K'].median(), inplace=True)\n    df['Drug'].fillna(df['Drug'].mode()[0], inplace=True)\n\n   # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['Sex'] = label_encoder.fit_transform(df['Sex'])\n    df['BP'] = label_encoder.fit_transform(df['BP'])\n    df['Cholesterol'] = label_encoder.fit_transform(df['Cholesterol'])\n\n    # Select features\n    features = ['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K', 'Drug']\n    return df[features]\n\n# Load the dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/alexandremartinelli11/machine-learning/refs/heads/main/data/kaggle/drug200.csv')\ndf = df.sample(n=10, random_state=42)\n\n# Preprocessing\ndf = preprocess(df)\n\n# Display the first few rows of the dataset\nprint(df.to_markdown(index=False))\n</code></pre> Age N-Age Z-Age Na_to_K N-Na_to_K Z-Na_to_K 95 36 0.4 -0.117416 11.424 0.130411 -0.526121 15 16 0 -1.23566 15.516 0.291292 -0.0105705 30 18 0.04 -1.12384 8.75 0.0252801 -0.863018 158 59 0.86 1.16857 10.444 0.0918813 -0.649591 128 47 0.62 0.49762 33.542 1 2.26052 115 51 0.7 0.72127 18.295 0.40055 0.339555 69 18 0.04 -1.12384 24.276 0.635699 1.0931 170 28 0.24 -0.564715 12.879 0.187615 -0.342806 174 42 0.52 0.218058 12.766 0.183173 -0.357043 45 66 1 1.55996 8.107 0 -0.944029 <pre><code>import pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\n\ndef standardization(df):\n\n    df['Z-Age'] = df['Age'].apply(lambda x: (x-df['Age'].mean())/df['Age'].std())\n    df['N-Age'] = df['Age'].apply(lambda x: (x-df['Age'].min())/(df['Age'].max()-df['Age'].min()))\n    df['Z-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x-df['Na_to_K'].mean())/df['Na_to_K'].std())\n    df['N-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x-df['Na_to_K'].min())/(df['Na_to_K'].max()-df['Na_to_K'].min()))\n    df = df[['Age', 'N-Age', 'Z-Age', 'Na_to_K', 'N-Na_to_K', 'Z-Na_to_K']].dropna()\n    print(df.head(10).to_markdown())\n\ndef preprocess(df):\n    # Fill missing values\n    df['Age'].fillna(df['Age'].median(), inplace=True)\n    df['Sex'].fillna(df['Sex'].mode()[0], inplace=True)\n    df['BP'].fillna(df['BP'].mode()[0], inplace=True)\n    df['Cholesterol'].fillna(df['Cholesterol'].mode()[0], inplace=True)\n    df['Na_to_K'].fillna(df['Na_to_K'].median(), inplace=True)\n    df['Drug'].fillna(df['Drug'].mode()[0], inplace=True)\n\n   # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['Sex'] = label_encoder.fit_transform(df['Sex'])\n    df['BP'] = label_encoder.fit_transform(df['BP'])\n    df['Cholesterol'] = label_encoder.fit_transform(df['Cholesterol'])\n\n    # Select features\n    features = ['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K', 'Drug']\n    return df[features]\n\n# Load the dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/alexandremartinelli11/machine-learning/refs/heads/main/data/kaggle/drug200.csv')\ndf = df.sample(n=10, random_state=42)\n\n# Preprocessing\ndf = preprocess(df)\n\nstandardization(df)\n</code></pre>"},{"location":"arvore/main/#divisao-dos-dados","title":"Divis\u00e3o dos Dados","text":"<p>O conjunto de dados foi dividido em 70% para treino e 30% para valida\u00e7\u00e3o, garantindo que o modelo fosse treinado em uma parte significativa das observa\u00e7\u00f5es, mas ainda avaliado em dados n\u00e3o vistos. O uso do conjunto de valida\u00e7\u00e3o tem como objetivo detectar e reduzir o risco de overfitting.</p>"},{"location":"arvore/main/#treinamento-do-modelo","title":"Treinamento do Modelo","text":"Result 80% 20%Result 70% 30%Result 60% 40%Result 50% 50%Result 40% 60%Code <p>Accuracy: 1.0 </p>Relat\u00f3rio de Classifica\u00e7\u00e3o: precision recall f1-score support drugA 1.0 1.0 1.0 6.0 drugB 1.0 1.0 1.0 3.0 drugC 1.0 1.0 1.0 5.0 drugX 1.0 1.0 1.0 11.0 drugY 1.0 1.0 1.0 15.0 accuracy 1.0 1.0 1.0 1.0 macro avg 1.0 1.0 1.0 40.0 weighted avg 1.0 1.0 1.0 40.0 Matriz de Confus\u00e3o: drugA drugB drugC drugX drugY drugA 6 0 0 0 0 drugB 0 3 0 0 0 drugC 0 0 5 0 0 drugX 0 0 0 11 0 drugY 0 0 0 0 15 Feature Importances:  Feature Importance 3 N-Na_to_K 0.493261 1 BP 0.265658 0 N-Age 0.135510 2 Cholesterol 0.105571 2025-09-28T23:59:32.393480 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ <p></p> <p>Accuracy: 1.0 </p>Relat\u00f3rio de Classifica\u00e7\u00e3o: precision recall f1-score support drugA 1.0 1.0 1.0 7.0 drugB 1.0 1.0 1.0 3.0 drugC 1.0 1.0 1.0 6.0 drugX 1.0 1.0 1.0 18.0 drugY 1.0 1.0 1.0 26.0 accuracy 1.0 1.0 1.0 1.0 macro avg 1.0 1.0 1.0 60.0 weighted avg 1.0 1.0 1.0 60.0 Matriz de Confus\u00e3o: drugA drugB drugC drugX drugY drugA 7 0 0 0 0 drugB 0 3 0 0 0 drugC 0 0 6 0 0 drugX 0 0 0 18 0 drugY 0 0 0 0 26 Feature Importances:  Feature Importance 3 N-Na_to_K 0.476110 1 BP 0.267512 0 N-Age 0.148169 2 Cholesterol 0.108209 2025-09-28T23:59:32.654982 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ <p></p> <p>Accuracy: 1.0 </p>Relat\u00f3rio de Classifica\u00e7\u00e3o: precision recall f1-score support drugA 1.0 1.0 1.0 10.0 drugB 1.0 1.0 1.0 6.0 drugC 1.0 1.0 1.0 6.0 drugX 1.0 1.0 1.0 25.0 drugY 1.0 1.0 1.0 33.0 accuracy 1.0 1.0 1.0 1.0 macro avg 1.0 1.0 1.0 80.0 weighted avg 1.0 1.0 1.0 80.0 Matriz de Confus\u00e3o: drugA drugB drugC drugX drugY drugA 10 0 0 0 0 drugB 0 6 0 0 0 drugC 0 0 6 0 0 drugX 0 0 0 25 0 drugY 0 0 0 0 33 Feature Importances:  Feature Importance 3 N-Na_to_K 0.481166 1 BP 0.258655 0 N-Age 0.138054 2 Cholesterol 0.122125 2025-09-28T23:59:32.917678 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ <p></p> <p>Accuracy: 1.0 </p>Relat\u00f3rio de Classifica\u00e7\u00e3o: precision recall f1-score support drugA 1.0 1.0 1.0 16.0 drugB 1.0 1.0 1.0 8.0 drugC 1.0 1.0 1.0 7.0 drugX 1.0 1.0 1.0 27.0 drugY 1.0 1.0 1.0 42.0 accuracy 1.0 1.0 1.0 1.0 macro avg 1.0 1.0 1.0 100.0 weighted avg 1.0 1.0 1.0 100.0 Matriz de Confus\u00e3o: drugA drugB drugC drugX drugY drugA 16 0 0 0 0 drugB 0 8 0 0 0 drugC 0 0 7 0 0 drugX 0 0 0 27 0 drugY 0 0 0 0 42 Feature Importances:  Feature Importance 3 N-Na_to_K 0.507161 1 BP 0.246185 2 Cholesterol 0.134811 0 N-Age 0.111843 2025-09-28T23:59:33.180391 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ <p></p> <p>Accuracy: 0.9916666666666667 </p>Relat\u00f3rio de Classifica\u00e7\u00e3o: precision recall f1-score support drugA 1.000000 1.000000 1.000000 17.000000 drugB 1.000000 1.000000 1.000000 11.000000 drugC 1.000000 1.000000 1.000000 8.000000 drugX 1.000000 0.970588 0.985075 34.000000 drugY 0.980392 1.000000 0.990099 50.000000 accuracy 0.991667 0.991667 0.991667 0.991667 macro avg 0.996078 0.994118 0.995035 120.000000 weighted avg 0.991830 0.991667 0.991646 120.000000 Matriz de Confus\u00e3o: drugA drugB drugC drugX drugY drugA 17 0 0 0 0 drugB 0 11 0 0 0 drugC 0 0 8 0 0 drugX 0 0 0 33 1 drugY 0 0 0 0 50 Feature Importances:  Feature Importance 3 N-Na_to_K 0.512857 1 BP 0.265714 2 Cholesterol 0.117384 0 N-Age 0.104045 2025-09-28T23:59:33.529835 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ <p></p> <pre><code>import matplotlib.pyplot as plt\nimport pandas as pd\n\nfrom io import StringIO\nfrom sklearn import tree\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.metrics import accuracy_score, classification_report, confusion_matrix\n\ndef standardization(df):\n\n    df['Z-Age'] = df['Age'].apply(lambda x: (x-df['Age'].mean())/df['Age'].std())\n    df['N-Age'] = df['Age'].apply(lambda x: (x-df['Age'].min())/(df['Age'].max()-df['Age'].min()))\n    df['Z-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x-df['Na_to_K'].mean())/df['Na_to_K'].std())\n    df['N-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x-df['Na_to_K'].min())/(df['Na_to_K'].max()-df['Na_to_K'].min()))\n    features = ['N-Age', 'Sex', 'BP', 'Cholesterol', 'N-Na_to_K', 'Drug']\n    return df[features]\n\ndef preprocess(df):\n    # Fill missing values\n    df['Age'].fillna(df['Age'].median(), inplace=True)\n    df['Sex'].fillna(df['Sex'].mode()[0], inplace=True)\n    df['BP'].fillna(df['BP'].mode()[0], inplace=True)\n    df['Cholesterol'].fillna(df['Cholesterol'].mode()[0], inplace=True)\n    df['Na_to_K'].fillna(df['Na_to_K'].median(), inplace=True)\n    df['Drug'].fillna(df['Drug'].mode()[0], inplace=True)\n\n   # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['Sex'] = label_encoder.fit_transform(df['Sex'])\n    df['BP'] = label_encoder.fit_transform(df['BP'])\n    df['Cholesterol'] = label_encoder.fit_transform(df['Cholesterol'])\n\n    # Select features\n    features = ['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K', 'Drug']\n    return df[features]\n\n# Load the dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/alexandremartinelli11/machine-learning/refs/heads/main/data/kaggle/drug200.csv')\n\n# Preprocessing\nd = preprocess(df.copy())\nd = standardization(d)\n\nplt.figure(figsize=(12, 10))\n\n# Carregar o conjunto de dados\nx = d[['N-Age', 'BP', 'Cholesterol', 'N-Na_to_K']]\ny = d['Drug']\n\n# Dividir os dados em conjuntos de treinamento e teste\nx_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.6, random_state=42)\n\n# Criar e treinar o modelo de \u00e1rvore de decis\u00e3o\nclassifier = tree.DecisionTreeClassifier()\nclassifier.fit(x_train, y_train)\n\ny_pred = classifier.predict(x_test)\n\ncm = confusion_matrix(y_test, y_pred)\nlabels = classifier.classes_\ncm_df = pd.DataFrame(cm, index=labels, columns=labels)\n\nreport_dict = classification_report(y_test, y_pred, output_dict=True)\nreport_df = pd.DataFrame(report_dict).transpose()\n\n# Avaliar o modelo\naccuracy = classifier.score(x_test, y_test)\nprint(\"Accuracy:\", accuracy_score(y_test, y_pred))\n\nprint(\"&lt;h3&gt;Relat\u00f3rio de Classifica\u00e7\u00e3o:&lt;/h3&gt;\")\nprint(report_df.to_html(classes=\"table table-bordered table-striped\", border=0))\n\nprint(\"&lt;h3&gt;Matriz de Confus\u00e3o:&lt;/h3&gt;\")\nprint(cm_df.to_html(classes=\"table table-bordered table-striped\", border=0))\n\n# Optional: Print feature importances\nfeature_importance = pd.DataFrame({\n    'Feature': ['N-Age', 'BP', 'Cholesterol', 'N-Na_to_K'],\n    'Importance': classifier.feature_importances_\n})\nprint(\"&lt;br&gt;Feature Importances:\")\nprint(feature_importance.sort_values(by='Importance', ascending=False).to_html())\n\ntree.plot_tree(classifier)\n\n# Para imprimir na p\u00e1gina HTML\nbuffer = StringIO()\nplt.savefig(buffer, format=\"svg\")\nprint(buffer.getvalue())\n</code></pre>"},{"location":"arvore/main/#avaliacao-do-modelo","title":"Avalia\u00e7\u00e3o do Modelo","text":"<p>Como vimos na se\u00e7\u00e3o de treinamento, a base selecionada para o treinamento da \u00e1rvore n\u00e3o \u00e9 ideal, apresentando 100% de accuracy, precision, recall e F1-score em diferentes divis\u00f5es dos dados (80%/20%, 70%/30%, 60%/40%, 50%/50%),  apresentando pouca varia\u00e7\u00e3o apenas quando a divis\u00e3o chega em 40% treino e 60% teste. Isso indica que a \u00e1rvore de decis\u00e3o provavelmente est\u00e1 sofrendo de overfitting, ou seja, aprendeu particularidades espec\u00edficas da base em vez de padr\u00f5es gerais. Assim, embora apresente resultados excelentes nos testes, o modelo pode n\u00e3o generalizar bem para dados realmente novos. Uma poss\u00edvel melhoria seria aumentar a quantidade de dados para reduzir o overfitting.</p>"},{"location":"arvore/main/#referencias","title":"Refer\u00eancias","text":"<p>Material for MkDocs</p>"},{"location":"kmeans/main%202/","title":"Main 2","text":""},{"location":"kmeans/main%202/#diagrama-de-classes-do-banco","title":"Diagrama de Classes do Banco","text":"<pre><code>classDiagram\n    class Conta {\n        - String id\n        # double saldo\n        - Cliente cliente\n        + sacar(double valor)\n        + depositar(double valor)\n    }\n    class Cliente {\n        - String id\n        - String nome\n        - List&lt;Conta&gt; contas\n    }\n    class PessoaFisica {\n        - String cpf\n    }\n    class PessoaJuridica {\n        - String cnpj\n    }\n    class ContaCorrente {\n        - double limite\n        + sacar(double valor)\n    }\n    class ContaPoupanca {\n        + sacar(double valor)\n    }\n    Conta *-- Cliente\n    Conta &lt;|-- ContaCorrente\n    Conta &lt;|-- ContaPoupanca\n    Cliente &lt;|-- PessoaFisica\n    Cliente &lt;|-- PessoaJuridica</code></pre>"},{"location":"kmeans/main%202/#diagrama-de-sequencia-de-autorizacao","title":"Diagrama de Seq\u00fc\u00eancia de Autoriza\u00e7\u00e3o","text":"<pre><code>sequenceDiagram\n  autonumber\n  actor User\n  User-&gt;&gt;Auth Service: request with token\n  Auth Service-&gt;&gt;Auth Service: decodes the token and extracts claims\n  Auth Service-&gt;&gt;Auth Service: verifies permissions\n  critical allowed\n    Auth Service-&gt;&gt;Secured Resource: authorizes the request\n    Secured Resource-&gt;&gt;User: returns the response\n  option denied\n    Auth Service--&gt;&gt;User: unauthorized message\n  end  </code></pre>"},{"location":"kmeans/main%20copy/","title":"Main copy","text":""},{"location":"kmeans/main%20copy/#objetivo","title":"Objetivo","text":"<p>Aqui vai o objetivo macro do roteiro. Por que estamos fazendo o que estamos fazendo?</p>"},{"location":"kmeans/main%20copy/#montagem-do-roteiro","title":"Montagem do Roteiro","text":"<p>Os pontos \"tarefas\" s\u00e3o os passos que devem ser seguidos para a realiza\u00e7\u00e3o do roteiro. Eles devem ser claros e objetivos. Com evid\u00eancias claras de que foram realizados.</p>"},{"location":"kmeans/main%20copy/#tarefa-1","title":"Tarefa 1","text":"<p>Instalando o MAAS:</p> sudo snap install maas --channel=3.5/Stable <p></p> <p>Dashboard do MAAS</p> <p>Conforme ilustrado acima, a tela inicial do MAAS apresenta um dashboard com informa\u00e7\u00f5es sobre o estado atual dos servidores gerenciados. O dashboard \u00e9 composto por diversos pain\u00e9is, cada um exibindo informa\u00e7\u00f5es sobre um aspecto espec\u00edfico do ambiente gerenciado. Os pain\u00e9is podem ser configurados e personalizados de acordo com as necessidades do usu\u00e1rio.</p>"},{"location":"kmeans/main%20copy/#tarefa-2","title":"Tarefa 2","text":""},{"location":"kmeans/main%20copy/#app","title":"App","text":""},{"location":"kmeans/main%20copy/#tarefa-1_1","title":"Tarefa 1","text":""},{"location":"kmeans/main%20copy/#tarefa-2_1","title":"Tarefa 2","text":"<p>Exemplo de diagrama</p> <pre><code>architecture-beta\n    group api(cloud)[API]\n\n    service db(database)[Database] in api\n    service disk1(disk)[Storage] in api\n    service disk2(disk)[Storage] in api\n    service server(server)[Server] in api\n\n    db:L -- R:server\n    disk1:T -- B:server\n    disk2:T -- B:db</code></pre> <p>Mermaid</p>"},{"location":"kmeans/main%20copy/#questionario-projeto-ou-plano","title":"Question\u00e1rio, Projeto ou Plano","text":"<p>Esse se\u00e7\u00e3o deve ser preenchida apenas se houver demanda do roteiro.</p>"},{"location":"kmeans/main%20copy/#discussoes","title":"Discuss\u00f5es","text":"<p>Quais as dificuldades encontradas? O que foi mais f\u00e1cil? O que foi mais dif\u00edcil?</p>"},{"location":"kmeans/main%20copy/#conclusao","title":"Conclus\u00e3o","text":"<p>O que foi poss\u00edvel concluir com a realiza\u00e7\u00e3o do roteiro?</p>"},{"location":"kmeans/main/","title":"K-Means","text":""},{"location":"kmeans/main/#entrega-individual","title":"Entrega Individual","text":"<ol> <li>Alexandre Martinelli</li> </ol>"},{"location":"kmeans/main/#introducao","title":"Introdu\u00e7\u00e3o","text":"<ol> <li>Explora\u00e7\u00e3o de dados: Ao selecionar uma base no kaggle referentes a cinco tipos de rem\u00e9dio, rem\u00e9dio A, B, C, X e Y, tem como objetivo prever qual rem\u00e9dio o paciente teria uma resposta melhor. As colunas presentes nesse dataset s\u00e3o Idade, Sexo, Press\u00e3o Arterial, nivel de colesterol, nivel de s\u00f3dio para pot\u00e1ssio no sangue e rem\u00e9dio que seria nossa target. </li> </ol>"},{"location":"kmeans/main/#colunas","title":"Colunas","text":"<ol> <li>Age (Idade): Essa coluna temos a idade dos pacientes, com a idade minima presente de 15, idade m\u00e9dia de 44,3 e maxima de 74 sendo do tipo Integer. </li> <li>Sex (Sexo): Essa coluna tem o sexo de cada paciente, divididos em 52% Masculino e 48% feminino, dados do tipo String.</li> <li>Blood Pressure (Press\u00e3o Arterial): Essa coluna tem os niveis de press\u00e3o arterial de cada paciente sendo dividida em 39% HIGH, 29% NORMAL e 32% LOW, dados do tipo String.</li> <li>Cholesterol (nivel de colesterol): Essa coluna tem os niveis de colesterol de cada paciente sendo divididos em 52% HIGH e 49% NORMAL, dados do tipo String.</li> <li>Na_to_K (s\u00f3dio para pot\u00e1ssio): Essa coluna tem os a raz\u00e3o de s\u00f3dio para pot\u00e1ssio no sangue de um paciente, com a minima de 6,27, media de 16,1 e maxima de 38,2, dados do tipo Float/Decimal.</li> <li>Drug (rem\u00e9dio): Essa coluna tem os rem\u00e9dio de melhor resposta para o paciente, dados do tipo String.</li> </ol> Base Age Sex BP Cholesterol Na_to_K Drug 36 M LOW NORMAL 11.424 drugX 16 F HIGH NORMAL 15.516 drugY 18 F NORMAL NORMAL 8.75 drugX 59 F LOW HIGH 10.444 drugC 47 M LOW NORMAL 33.542 drugY 51 M HIGH HIGH 18.295 drugY 18 F HIGH NORMAL 24.276 drugY 28 F NORMAL HIGH 12.879 drugX 42 M HIGH NORMAL 12.766 drugA 66 F NORMAL NORMAL 8.107 drugX"},{"location":"kmeans/main/#pre-processamento","title":"Pr\u00e9-processamento","text":"<p>Primeiro foi feita uma verifica\u00e7\u00e3o em todas as colunas procurando valores faltantes e substituindo eles pela mediana em valores num\u00e9ricos ou pela moda em vari\u00e1veis categ\u00f3ricas. Como vimos na descri\u00e7\u00e3o das colunas temos tr\u00eas que possuem dados categ\u00f3ricos do tipo String, sendo elas Sex(Sexo), Blood Pressure(Press\u00e3o Arterial) e Cholesterol(nivel de colesterol), para conseguirmos utilizar essas informa\u00e7\u00f5es \u00e9 necessario convertelas em numeros, oque foi feito utilizando a biblioteca scikit-learn que possui a fun\u00e7\u00e3o LabelEncoder(), em seguida aplicamos dois tipos de escalonamento \u00e0s colunas num\u00e9ricas Age e Na_to_K: padroniza\u00e7\u00e3o (z-score) e normaliza\u00e7\u00e3o min-max.</p> ResultPrep CodeStandardizationStandardization code N-Age Sex BP Cholesterol N-Na_to_K Drug 0.4 1 1 1 0.130411 drugX 0 0 0 1 0.291292 drugY 0.04 0 2 1 0.0252801 drugX 0.86 0 1 0 0.0918813 drugC 0.62 1 1 1 1 drugY 0.7 1 0 0 0.40055 drugY 0.04 0 0 1 0.635699 drugY 0.24 0 2 0 0.187615 drugX 0.52 1 0 1 0.183173 drugA 1 0 2 1 0 drugX <pre><code>import pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\n\n# Preprocess the data\ndef preprocess(df):\n    # Fill missing values\n    df['Age'].fillna(df['Age'].median(), inplace=True)\n    df['Sex'].fillna(df['Sex'].mode()[0], inplace=True)\n    df['BP'].fillna(df['BP'].mode()[0], inplace=True)\n    df['Cholesterol'].fillna(df['Cholesterol'].mode()[0], inplace=True)\n    df['Na_to_K'].fillna(df['Na_to_K'].median(), inplace=True)\n    df['Drug'].fillna(df['Drug'].mode()[0], inplace=True)\n\n   # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['Sex'] = label_encoder.fit_transform(df['Sex'])\n    df['BP'] = label_encoder.fit_transform(df['BP'])\n    df['Cholesterol'] = label_encoder.fit_transform(df['Cholesterol'])\n\n    # Select features\n    features = ['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K', 'Drug']\n    return df[features]\n\n# Load the dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/alexandremartinelli11/machine-learning/refs/heads/main/data/kaggle/drug200.csv')\ndf = df.sample(n=10, random_state=42)\n\n# Preprocessing\ndf = preprocess(df)\n\n# Display the first few rows of the dataset\nprint(df.to_markdown(index=False))\n</code></pre> Age N-Age Z-Age Na_to_K N-Na_to_K Z-Na_to_K 95 36 0.4 -0.117416 11.424 0.130411 -0.526121 15 16 0 -1.23566 15.516 0.291292 -0.0105705 30 18 0.04 -1.12384 8.75 0.0252801 -0.863018 158 59 0.86 1.16857 10.444 0.0918813 -0.649591 128 47 0.62 0.49762 33.542 1 2.26052 115 51 0.7 0.72127 18.295 0.40055 0.339555 69 18 0.04 -1.12384 24.276 0.635699 1.0931 170 28 0.24 -0.564715 12.879 0.187615 -0.342806 174 42 0.52 0.218058 12.766 0.183173 -0.357043 45 66 1 1.55996 8.107 0 -0.944029 <pre><code>import pandas as pd\nfrom sklearn.preprocessing import LabelEncoder\n\ndef standardization(df):\n\n    df['Z-Age'] = df['Age'].apply(lambda x: (x-df['Age'].mean())/df['Age'].std())\n    df['N-Age'] = df['Age'].apply(lambda x: (x-df['Age'].min())/(df['Age'].max()-df['Age'].min()))\n    df['Z-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x-df['Na_to_K'].mean())/df['Na_to_K'].std())\n    df['N-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x-df['Na_to_K'].min())/(df['Na_to_K'].max()-df['Na_to_K'].min()))\n    df = df[['Age', 'N-Age', 'Z-Age', 'Na_to_K', 'N-Na_to_K', 'Z-Na_to_K']].dropna()\n    print(df.head(10).to_markdown())\n\ndef preprocess(df):\n    # Fill missing values\n    df['Age'].fillna(df['Age'].median(), inplace=True)\n    df['Sex'].fillna(df['Sex'].mode()[0], inplace=True)\n    df['BP'].fillna(df['BP'].mode()[0], inplace=True)\n    df['Cholesterol'].fillna(df['Cholesterol'].mode()[0], inplace=True)\n    df['Na_to_K'].fillna(df['Na_to_K'].median(), inplace=True)\n    df['Drug'].fillna(df['Drug'].mode()[0], inplace=True)\n\n   # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['Sex'] = label_encoder.fit_transform(df['Sex'])\n    df['BP'] = label_encoder.fit_transform(df['BP'])\n    df['Cholesterol'] = label_encoder.fit_transform(df['Cholesterol'])\n\n    # Select features\n    features = ['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K', 'Drug']\n    return df[features]\n\n# Load the dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/alexandremartinelli11/machine-learning/refs/heads/main/data/kaggle/drug200.csv')\ndf = df.sample(n=10, random_state=42)\n\n# Preprocessing\ndf = preprocess(df)\n\nstandardization(df)\n</code></pre>"},{"location":"kmeans/main/#divisao-dos-dados","title":"Divis\u00e3o dos Dados","text":"<p>O conjunto de dados foi dividido em 70% para treino e 30% para valida\u00e7\u00e3o, garantindo que o modelo fosse treinado em uma parte significativa das observa\u00e7\u00f5es, mas ainda avaliado em dados n\u00e3o vistos. O uso do conjunto de valida\u00e7\u00e3o tem como objetivo detectar e reduzir o risco de overfitting.</p>"},{"location":"kmeans/main/#treinamento-do-modelo","title":"Treinamento do Modelo","text":"Result 70% 30%Code <p>Acur\u00e1cia: 0.56% Matriz de Confus\u00e3o:  Classe Pred 0 Classe Pred 1 Classe Pred 2 Classe Pred 3 Classe Pred 4 Classe Real 0 0 0 0 0 17 Classe Real 1 0 0 0 0 13 Classe Real 2 0 0 0 0 11 Classe Real 3 0 0 0 43 0 Classe Real 4 0 0 0 30 46 2025-09-28T23:59:34.061538 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ </p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom io import StringIO\nimport pandas as pd\nfrom scipy.stats import mode\nfrom sklearn.preprocessing import LabelEncoder\nfrom sklearn.cluster import KMeans\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score, confusion_matrix\nfrom sklearn.decomposition import PCA  \n\n\nplt.figure(figsize=(12, 10))\n\ndef standardization(df):\n    df['Z-Age'] = df['Age'].apply(lambda x: (x - df['Age'].mean()) / df['Age'].std())\n    df['N-Age'] = df['Age'].apply(lambda x: (x - df['Age'].min()) / (df['Age'].max() - df['Age'].min()))\n    df['Z-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x - df['Na_to_K'].mean()) / df['Na_to_K'].std())\n    df['N-Na_to_K'] = df['Na_to_K'].apply(lambda x: (x - df['Na_to_K'].min()) / (df['Na_to_K'].max() - df['Na_to_K'].min()))\n    features = ['N-Age', 'Sex', 'BP', 'Cholesterol', 'N-Na_to_K', 'Drug']\n    return df[features]\n\ndef preprocess(df):\n    # Fill missing values\n    df['Age'].fillna(df['Age'].median(), inplace=True)\n    df['Sex'].fillna(df['Sex'].mode()[0], inplace=True)\n    df['BP'].fillna(df['BP'].mode()[0], inplace=True)\n    df['Cholesterol'].fillna(df['Cholesterol'].mode()[0], inplace=True)\n    df['Na_to_K'].fillna(df['Na_to_K'].median(), inplace=True)\n    df['Drug'].fillna(df['Drug'].mode()[0], inplace=True)\n\n    # Convert categorical variables\n    label_encoder = LabelEncoder()\n    df['Sex'] = label_encoder.fit_transform(df['Sex'])\n    df['BP'] = label_encoder.fit_transform(df['BP'])\n    df['Cholesterol'] = label_encoder.fit_transform(df['Cholesterol'])\n    df['Drug'] = label_encoder.fit_transform(df['Drug'])\n\n    features = ['Age', 'Sex', 'BP', 'Cholesterol', 'Na_to_K', 'Drug']\n    return df[features]\n\nlabel_encoder = LabelEncoder()\n# Load dataset\ndf = pd.read_csv('https://raw.githubusercontent.com/alexandremartinelli11/machine-learning/refs/heads/main/data/kaggle/drug200.csv')\n\n# Preprocessing\nd = preprocess(df.copy())\nd = standardization(d)\n\nX = d[['N-Age', 'BP', 'Cholesterol', 'N-Na_to_K']]\ny = d['Drug']\n\n#Separar em teste e valida\u00e7\u00e3o\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n# Reduzir para 2 dimens\u00f5es com PCA\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X_train)\n\n# Treinar KMeans\nkmeans = KMeans(n_clusters=5, init=\"k-means++\", max_iter=100, random_state=42)\nlabels = kmeans.fit_predict(X_pca)\n\n# Mapear clusters para classes reais por voto majorit\u00e1rio\ncluster_map = {}\nfor c in np.unique(labels):\n    mask = labels == c\n    majority_class = mode(y_train[mask], keepdims=False)[0]\n    cluster_map[c] = majority_class\n\n# Reatribuir clusters como classes previstas\ny_pred = np.array([cluster_map[c] for c in labels])\n\n# Calcular acur\u00e1cia e matriz de confus\u00e3o\nacc = accuracy_score(y_train, y_pred)\ncm = confusion_matrix(y_train, y_pred)\n\ncm_df = pd.DataFrame(\n    cm,\n    index=[f\"Classe Real {cls}\" for cls in np.unique(y_train)],\n    columns=[f\"Classe Pred {cls}\" for cls in np.unique(y_train)]\n)\n\nprint(f\"Acur\u00e1cia: {acc:.2f}%\")\nprint(\"&lt;br&gt;Matriz de Confus\u00e3o:\")\nprint(cm_df.to_html())\n\n# Tamb\u00e9m projetar os centr\u00f3ides no PCA\ncentroids_pca = kmeans.cluster_centers_\n\n\n# Plot results\nplt.figure(figsize=(10, 8))\nplt.scatter(X_pca[:, 0], X_pca[:, 1], c=labels, cmap='viridis', s=50)\nplt.scatter(centroids_pca[:, 0], centroids_pca[:, 1], \n           c='red', marker='*', s=200, label='Centroids')\nplt.title('K-Means Clustering (PCA 2D)')\nplt.xlabel('Principal Component 1')\nplt.ylabel('Principal Component 2')\nplt.legend()\n\n# Save plot to buffer\nbuffer = StringIO()\nplt.savefig(buffer, format=\"svg\", transparent=True)\nprint(buffer.getvalue())\n</code></pre>"},{"location":"kmeans/main/#avaliacao-do-modelo","title":"Avalia\u00e7\u00e3o do Modelo","text":"<p>O K-Means, mesmo ap\u00f3s redu\u00e7\u00e3o com PCA, n\u00e3o conseguiu reproduzir bem as cinco classes do conjunto de dados. A matriz de confus\u00e3o mostra que os clusters formados concentram-se principalmente em duas classes, indicando que o algoritmo n\u00e3o separou adequadamente todas as categorias. Assim, a acur\u00e1cia obtida reflete apenas a sobreposi\u00e7\u00e3o entre clusters e classes reais. Uma poss\u00edvel melhoria seria aumentar a quantidade de dados.</p>"},{"location":"kmeans/main/#referencias","title":"Refer\u00eancias","text":"<p>Material for MkDocs</p>"},{"location":"projeto/main/","title":"Projeto","text":"<p>Aqui vai toda a documenta\u00e7\u00e3o do projeto, incluindo o que j\u00e1 foi feito e o que falta fazer.</p>"},{"location":"roteiro3/main/","title":"Roteiro 3","text":"<p>Running the code below in Browser (Woooooowwwwww!!!!!!). <sup>1</sup></p> <p> </p> Editor (session: default) Run <pre>import ssl\nimport pandas as pd\n\ndf = pd.DataFrame()\ndf['AAPL'] = pd.Series([1, 2, 3])\ndf['MSFT'] = pd.Series([4, 5, 6])\ndf['GOOGL'] = pd.Series([7, 8, 9])\n\nprint(df)\n</pre> Output Clear <pre></pre> <p></p> <ol> <li> <p>Pyodide \u21a9</p> </li> </ol>"},{"location":"roteiro4/main/","title":"Roteiro 4","text":"<p>Se chegou aqui, \u00e9 porque voc\u00ea est\u00e1 interessado em saber mais. Logo, de brinde, como rodar um c\u00f3digo <code>Python</code> aqui.</p> 2025-09-28T23:59:34.315244 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ 2025-09-28T23:59:35.613940 image/svg+xml Matplotlib v3.10.6, https://matplotlib.org/ <p>Markdown-exec \u00e9 uma extens\u00e3o do Markdown que permite executar c\u00f3digo Python diretamente no Markdown. Isso \u00e9 \u00fatil para gerar resultados din\u00e2micos ou executar scripts de forma interativa.</p>"}]}